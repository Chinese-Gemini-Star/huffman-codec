# huffman-codec

一个简易的霍夫曼编译码器,同时这也是我数据结构的课程设计

已部署在个人网站中:[https://huffman.geministar.site](https://huffman.geministar.site)

以下内容摘自课设报告

## 题目

利用霍夫曼编码进行通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。这要求在发送端通过一个编码系统对待传输数据预先编码，在接收端将传来的数据进行译码（复原）。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编/译码系统。现在需要为这样的信息收发站编写一个霍夫曼码的编/译码系统。

## 需求分析

首先软件必须具有霍夫曼编译码的基础能力，即能够读入原码，并将其转化为霍夫曼密文；同时也能够读入密文，将其转化为霍夫曼原码。为此还要有初始化霍夫曼树的能力，即根据指定的字符集，来生成霍夫曼树。

在这些基本功能之外，考虑到信息收发站可能使用特殊的操作系统，或者不方便安装本地软件。因此本软件采用webapp形式，实际上是一个saas（软件即服务）的系统。为了方便霍夫曼树的生成和传递，还应该提供根据原文生成霍夫曼树、手动指定已生成过的霍夫曼树的功能。同时原码和密码要能够保存在本地，以及从本地上传，以便持久化管理。此外，也需要有p2p（点对点）传输的功能，以便在两个信息站直接收发密文。更进一步，为了方便查看霍夫曼树，还需要能够输出霍夫曼树。

## 概要设计

首先，系统整体采用B/S（浏览器/服务器）架构，采用前后端分离的形式进行开发。前端主要负责与用户进行交互，后端主要负责实现业务逻辑。

生成霍夫曼树的过程如下：首先生成每个字符对应的节点，并将这些字符的频率作为权值。然后将这些节点放入一个优先队列中，每次从优先队列中取出两个权值最小的节点，构建一个新的节点作为他们的父节点，然后将这个父节点加入优先队列中。如此循环直到优先队列中只有最后一个节点，此即为霍夫曼树的根节点。此时霍夫曼树构建完毕。

霍夫曼编码的过程如下：先遍历霍夫曼树，向左遍历记为0，向右遍历记为1。到达每个字符的路径上的01串即为此字符的编码，将字符和他的编码做成一个映射（如哈希表），然后遍历原文，逐个取出他们的编码即可。为了方便存储和展示，将这些编码看作二进制数，全部转换为16进制数存储。这里有一个问题是如何在补齐8位之后，在译码时能够知道什么时候译码完毕。我这里的解决方法是再编码一个终止符\0，在译码时读取到终止符就停止译码。

霍夫曼译码的过程如下：翻转编码时所使用的映射（即取反射），遍历密文（如果为16进制，先转为2进制，然后整体视为一个字符串），逐个字符累加，如果当前累加的结果存在一个映射，也就是是一个字符的编码，那么那个字符就是他的原码，记录在结果中。如是操作直到遇到中止符。如果始终没有遇到终止符，那说明密文有问题。

根据原文生成霍夫曼树非常容易，只需要先遍历一遍原文，统计每个字符的频率即可，借助映射可以非常容易的实现。

选中已有的霍夫曼树的核心要点是如何区分霍夫曼树。这里我对每个已生成的霍夫曼树采用DOT格式进行序列化，然后取其序列化结果的MD5码值。由于MD5码值在极大多数情况下不重复，所以可以以此来区分不同的霍夫曼树。将这个MD5码值视为霍夫曼树的ID即可。

保存和读取原码译码直接调用编程语言自身的库即可。由于是前后端项目，所以保存的实质就是触发浏览器下载行为，读取的实质就是将文件作为表单的内容提交到服务器端。

p2p传输的核心是如何定位对方。在实际应用中，两个信息站应当是具有各自的公网ip的，直接通过公网ip定位即可。但作为普通学生，我们无法在日常生活中直接使用公网ip。所以这里采用用户名代替公网ip，并且借助服务器来中转。虽然并没有真正实现p2p通信，但是实际效果大致一致。

## 程序说明

在源码文件中，`/server`目录下为服务端，`/tmp`目录下为文件缓存，`/webapp`目录下为前端。根目录下的`huffman-codec.exe`为windows系统下启动服务器的可执行文件，`huffman-codec`为linux大多发行版下启动服务器的可执行文件。自认为各个文件名命名很清晰易懂，其他文件就不一一说明了。

本地运行可执行文件后，打开浏览器访问 <http://localhost:24434/> 即可使用此系统（p2p传输功能除外，需要另行配置mysql数据库，此处不做说明）。如果部署在公网服务器上，那把localhost部分替换成对应的ip地址即可。

如需要自行编译，请安装golang 1.21.3版本，并配置相关环境，并且确保开启go mod功能。然后在根目录下执行go build命令即可完成编译。具体配置过程请自行查看官方文档。此处我已经帮你完成了编译的过程，直接运行我编译后的文件即可。

## 调试分析

构建霍夫曼树的时间复杂度是 $O(nlogn)$ ，n为字符集长度。空间复杂度也为 $O(nlogn)$

霍夫曼编码的时间复杂度是 $O(mlogm + n)$ ,n为待编码字符串长度，m为字符集长度。其中前面的 $O(mlogm)$ 为获取霍夫曼编码所用的时间，如果获取一次后就进行缓存，那么后续每次编码只需要 $O(n)$ 的复杂度即可。空间复杂度同理。

霍夫曼解码的时间复杂度是 $O(n)$，n为待解码字符串长度。

本程序主要的时间瓶颈还是在文件读取以及网络传输上。这一点出于个人水平暂时无法进行优化。但是编译码的过程可以通过拆分成多个线程，充分利用go语言协程的优势来提速。只要合理拆分线程，代码的实际运行效率理论上应当可以大大提升。

## 实验心得与体会（总结）

在这次实验中，我进一步的锻炼了自己的编程能力、解决问题的能力和活学活用开源库的能力。

在前端设计方面，我进一步认识和深化了原生html的盒子模型以及其排版布局的方式。在使用js+jquery编写前端脚本的时候，也让我对jquery这个框架有了更深的了解（虽然这个框架在实际开发中已经用的越来越少了）。同时这也是我第一次使用js原生的文件读写功能，js的文件读写更加接近二进制层面，也让我对数据在计算机底层的存储有了更深的认识。

在后端设计方面，通过用go编写算法，并且考虑对时间的优化，让我对go中一些常用操作的不同写法在时空方面的开销差异有了一定的了解，也让我认识到了很多以前没有用过的开源库。通过这次编写，我对iris框架以及mvc设计模式有了更深的了解，并且运用的更加熟练。

在这次编写的过程中，我遇到了很多问题。在不断查阅资料、询问他人最终尝试自己解决的过程中，进一步我锻炼了自己的思维能力和解决问题的能力。
